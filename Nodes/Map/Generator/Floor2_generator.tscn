[gd_scene load_steps=7 format=2]

[ext_resource path="res://Resources/Textures/1px.png" type="Texture2D" id=1]

[sub_resource type="Shader" id=21]
code = "shader_type canvas_item;
uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;

uniform float cutoff=0.3;
uniform sampler2D gradint_texture;


uniform float falloff=0.1;
uniform float first=0.1;
uniform float second=0.3;
uniform float third=0.5;
uniform float fourth=0.7;
uniform float myrange=0.1;



uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo=0.5;
uniform float testowo2=0.5;





float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 offset)
{
	float col=circle((st*2.0),circle_add);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}
	
void fragment()
{
    vec3 color = vec3(0.0);
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 sca=scale*0.01;
	color=vec3(1.0,0.0,0.0);
	/*
	//dig difficulty
	vec2 st=(UV-0.5)*2.0;
	vec2 offset=vec2(float(seed));
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	color.g=(round(clamp(6.0-pow((round(col*12.0)),1.2),0.0,6.0))*8.0)/255.0;
	
	/*color=max(color,multiple_islands(UV_TEX,tex_size,10,0)*vec3(1.0,0.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,100)*vec3(1.0,8.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,200)*vec3(1.0,16.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,300)*vec3(1.0,24.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,400)*vec3(1.0,32.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,500)*vec3(1.0,40.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,600)*vec3(1.0,48.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,700)*vec3(1.0,56.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,800)*vec3(1.0,64.0/255.0,0.0));*/
//float empty=multiple_islands(UV_TEX,tex_size,100,900);
  //  COLOR= (1.0-empty)*vec4(color,1.0)+empty*vec4(0.0,0.0,0.0,0.0);

	//random points
//	vec2 pixel_UV=round(UV/TEXTURE_PIXEL_SIZE)*TEXTURE_PIXEL_SIZE;
//	COLOR=vec4(0.0,4.0,0.0,1.0)*random_places(pixel_UV,10.0,3);
/*
	if(color.r==1.0 && color.g==0.0 && color.b==0.0)
		if(enlarged_paths(UV,TEXTURE_PIXEL_SIZE,seed)==1.0)
			color=vec3(0.0,0.0,0.0);
	*/

		//lumps
	//color.rgb*=vec3(step(pow(fbm(UV*5.0*10.0+fbm(UV*100.0,2),2),15.0),0.0005));
	
	//river
	float is_river=pow(turb(fbm(UV_s*10.0,4)*0.1+fbm(UV_s*100.0,4)*0.01+UV_s,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_tunnel=pow(turb(fbm(UV_s*test2*10.0,4)*0.3+fbm(UV_s*test2*100.0,4)*0.01+UV_s*test2*2.0,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);

	//float is_cave=pow(turb(fbm(UV*test2*10.0,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2*2.0+float(seed),1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_cave=is_tunnel*15.0;
	is_cave+=float((fbm(UV_s*70.0+vec2(turb(UV_s*10.0,4),turb(UV_s*11.0,4))*1.095,1)-0.43*test3))*0.629*test4;
	if(is_cave<-0.016*test5 || is_tunnel<0.006)color=vec3(0.0,0.0,0.0);
	
	if( is_river<0.0015)
		color.r=((is_river/0.0015)+0.3);	
	if(step(is_river,0.0001)>0.0)
		color=vec3(1.0,240.0/255.0,0.0);
	
	//float is_river=pow(turb(fbm(UV*10.0*test2,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2+float(seed),1)*fbm(UV*test2+2.0,1)*1.0,1.9);


	color.rgb*=(1.0-island((UV-vec2(0.5,0.5))*10.0,vec2(float(seed))));
	
	if(color.r==0.0 && color.g==0.0 && color.b==0.0)
		COLOR=vec4(color,0.0);
	else
		COLOR=vec4(color,1.0);
	
	COLOR=vec4(0.0,0.0,0.0,1.0);
	vec3 colors [4]= {vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,0.0,1.0),vec3(0.0,0.0,0.0)};
	float col=0.0;
	for( int i=0;i<4;i++)
	{

		if (noise_type==0)
			col=fbm((UV05)*noise_tile*sca-(seedf+float(i)*23.0),NUM_OCTAVES)*noise_mul;
		if (noise_type==1)
			col=fbmf((UV05)*noise_tile*sca-(seedf+float(i)*23.0),NUM_OCTAVES)*noise_mul;
		if (noise_type==2)
			col=turb((UV05)*noise_tile*sca-(seedf+float(i)*23.0),NUM_OCTAVES)*noise_mul;
		if (noise_type==3)
			col=ridge((UV05)*noise_tile*sca-(seedf+float(i)*23.0),NUM_OCTAVES)*noise_mul;
		//col+=circle((UV05*2.0),0.0)*additional_circle_add;

		COLOR.rgb+=texture(gradint_texture,vec2(col,0.0)).rgb*colors[i];
	}
	/*	
	COLOR=vec4(island(UV-0.5,vec2(float(seed))));
	COLOR=vec4(circle((UV-0.5)*1.5,float(0.0)));
	COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
		*/
	//COLOR=vec4(vec3(         step(   turb(UV*30.1,3),0.3   )        ),1.0);
	//COLOR=vec4(vec3(         island((UV-vec2(0.5))*1.5,vec2(0163323.5))       ),1.0);
	//COLOR=vec4(vec3(      step(fbm(UV*10.0,8)   ,godotcon)      ),1.0);
	//COLOR=vec4(vec3(   step( turb(UV*10.0,8) ,godotcon) ),1.0);
	//COLOR=vec4(0.0);
	//COLOR+= step(  turb(UV*10.0,7)  , testowo2);
	
}

"

[sub_resource type="Gradient" id=19]
offsets = PackedFloat32Array( 0, 0.194672, 0.420082, 0.692623 )
colors = PackedColorArray( 1, 1, 1, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0 )

[sub_resource type="GradientTexture2D" id=20]
gradient = SubResource( 19 )

[sub_resource type="ShaderMaterial" id=22]
shader = SubResource( 21 )
shader_param/scale = Vector2( 1024, 1024 )
shader_param/seed = 77
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.272
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 1.0
shader_param/init_add = 0.0
shader_param/noise_tile = 1.0
shader_param/noise_mul = 0.855
shader_param/cutoff = 0.3
shader_param/falloff = 0.1
shader_param/first = 0.1
shader_param/second = 0.3
shader_param/third = 0.5
shader_param/fourth = 0.7
shader_param/myrange = 0.1
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 0.717
shader_param/test2 = 0.462
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/gradint_texture = SubResource( 20 )

[sub_resource type="GDScript" id=17]
script/source = "extends Sprite2D
tool

@export var my_seed =0: set = set_seed



func set_seed(newseed):
	my_seed=newseed
	material.set_shader_parameter(\"seed\",my_seed)
	


func refresh_scale():
	material.set_shader_parameter(\"scale\",global_scale)
func _notification(what):
	if what == NOTIFICATION_TRANSFORM_CHANGED:
		refresh_scale()

"

[node name="floor2gen" type="Sprite2D"]
material = SubResource( 22 )
scale = Vector2( 1024, 1024 )
texture = ExtResource( 1 )
centered = false
script = SubResource( 17 )
my_seed = 77
