[gd_scene load_steps=70 format=2]

[ext_resource path="res://Nodes/Map/Generator/SceneMapGenerator.gd" type="Script" id=1]
[ext_resource path="res://Nodes/Map/Generator/WhiteBlob.gd" type="Script" id=2]
[ext_resource path="res://Nodes/Map/Generator/GeneratedMapBase.gd" type="Script" id=3]
[ext_resource path="res://Resources/Textures/1px_really_white.png" type="Texture2D" id=4]
[ext_resource path="res://Resources/Materials/PixelMapMaterial.tres" type="Material" id=5]
[ext_resource path="res://Resources/Textures/1px.png" type="Texture2D" id=6]
[ext_resource path="res://Nodes/Map/Generator/generated_rects.gd" type="Script" id=7]
[ext_resource path="res://Nodes/Map/Generator/rect_generator.gd" type="Script" id=8]
[ext_resource path="res://Nodes/Map/MapPixelMap.gd" type="Script" id=9]
[ext_resource path="res://Nodes/Map/Generator/caves_gen.gd" type="Script" id=10]
[ext_resource path="res://Nodes/Map/Generator/RectGenerators/mine_in_metal.gd" type="Script" id=11]
[ext_resource path="res://Nodes/Map/Generator/reactor_rect.gd" type="Script" id=12]
[ext_resource path="res://Nodes/Map/Generator/RectGenerators/rich_swarm_batch.gd" type="Script" id=13]
[ext_resource path="res://Nodes/Map/Generator/RectGenerators/wave_spawner_spawner.gd" type="Script" id=14]
[ext_resource path="res://Nodes/Map/Generator/RectGenerators/mine_rect.gd" type="Script" id=15]
[ext_resource path="res://Nodes/Map/Generator/resource_rect.gd" type="Script" id=16]
[ext_resource path="res://Nodes/Map/Generator/lava_rect.gd" type="Script" id=17]
[ext_resource path="res://Nodes/Map/Generator/ChunkGenerators/TunnelChunk.tscn" type="PackedScene" id=18]
[ext_resource path="res://Nodes/Map/Generator/stone_gate_vault.gd" type="Script" id=19]
[ext_resource path="res://Nodes/Map/Generator/crafted_rect.gd" type="Script" id=20]
[ext_resource path="res://Nodes/Map/Generator/CraftedBlob.gd" type="Script" id=21]
[ext_resource path="res://Nodes/Map/Generator/RectGenerators/MonsterLair.gd" type="Script" id=22]

[sub_resource type="PixelMapMaterialData" id=106]
resource_local_to_scene = true
name_table = PackedStringArray( "Dirt", "Clay", "Rocks", "Poor Metal", "Metal", "Rich Metal", "Rock6", "Rock9", "Foam", "Steel", "Fireproof Foam", "Unused", "Concrete", "Unused", "Unused", "Unused", "Unused", "Unnamed", "Unnamed", "Unnamed", "Low building", "Wall", "Upgraded Wall", "Upgraded II Wall", "Tar", "Empty", "Dead Lumen", "Lumen", "Gate", "Water", "Lava", "Unnamed", "Building", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed", "Unnamed" )
durability_table = PackedInt32Array( 1, 5, 100, 1, 3, 9, 6, 9, 1, 8, 1, 1, 80, 2, 2, 1, 1, 2, 1, 1, 255, 2, 4, 6, 1, 1, 25, 1, 254, 1, 1, 1, 9999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 )
simulated_materials = PackedInt32Array( 15, 16 )
reaction_table = PackedInt32Array( 15, 16, 14 )

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

void fragment() {
	vec4 color = texture(TEXTURE, UV);
	color.rgb = vec3(1.0) - color.rgb;
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=268]
shader = SubResource( 1 )

[sub_resource type="Shader" id=90]
code = "shader_type canvas_item;
uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo=0.5;
uniform float testowo2=0.5;

uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;
uniform bool tile_scale=true;

float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 offset)
{
	float col=circle((st*2.0),circle_add);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}
	
void fragment()
{
    vec3 color = vec3(0.0);
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 sca=scale*0.01;
	vec2 sca_norm=scale/max(scale.x,scale.y);
	color=vec3(1.0,0.0,0.0);
	/*
	//dig difficulty
	vec2 st=(UV-0.5)*2.0;
	vec2 offset=vec2(float(seed));
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	color.g=(round(clamp(6.0-pow((round(col*12.0)),1.2),0.0,6.0))*8.0)/255.0;
	
	/*color=max(color,multiple_islands(UV_TEX,tex_size,10,0)*vec3(1.0,0.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,100)*vec3(1.0,8.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,200)*vec3(1.0,16.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,300)*vec3(1.0,24.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,400)*vec3(1.0,32.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,500)*vec3(1.0,40.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,600)*vec3(1.0,48.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,700)*vec3(1.0,56.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,800)*vec3(1.0,64.0/255.0,0.0));*/
//float empty=multiple_islands(UV_TEX,tex_size,100,900);
  //  COLOR= (1.0-empty)*vec4(color,1.0)+empty*vec4(0.0,0.0,0.0,0.0);

	//random points
//	vec2 pixel_UV=round(UV/TEXTURE_PIXEL_SIZE)*TEXTURE_PIXEL_SIZE;
//	COLOR=vec4(0.0,4.0,0.0,1.0)*random_places(pixel_UV,10.0,3);
/*
	if(color.r==1.0 && color.g==0.0 && color.b==0.0)
		if(enlarged_paths(UV,TEXTURE_PIXEL_SIZE,seed)==1.0)
			color=vec3(0.0,0.0,0.0);
	*/

		//lumps
	//color.rgb*=vec3(step(pow(fbm(UV*5.0*10.0+fbm(UV*100.0,2),2),15.0),0.0005));
	
	//river
	float is_river=pow(turb(fbm(UV_s*10.0,4)*0.1+fbm(UV_s*100.0,4)*0.01+UV_s,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_tunnel=pow(turb(fbm(UV_s*test2*10.0,4)*0.3+fbm(UV_s*test2*100.0,4)*0.01+UV_s*test2*2.0,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);

	//float is_cave=pow(turb(fbm(UV*test2*10.0,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2*2.0+float(seed),1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_cave=is_tunnel*15.0;
	is_cave+=float((fbm(UV_s*70.0+vec2(turb(UV_s*10.0,4),turb(UV_s*11.0,4))*1.095,1)-0.43*test3))*0.629*test4;
	if(is_cave<-0.016*test5 || is_tunnel<0.006)color=vec3(0.0,0.0,0.0);
	
	if( is_river<0.0015)
		color.r=((is_river/0.0015)+0.3);	
	if(step(is_river,0.0001)>0.0)
		color=vec3(1.0,240.0/255.0,0.0);
	
	//float is_river=pow(turb(fbm(UV*10.0*test2,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2+float(seed),1)*fbm(UV*test2+2.0,1)*1.0,1.9);


	color.rgb*=(1.0-island((UV-vec2(0.5,0.5))*10.0,vec2(float(seed))));
	
	if(color.r==0.0 && color.g==0.0 && color.b==0.0)
		COLOR=vec4(color,0.0);
	else
		COLOR=vec4(color,1.0);
		
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	
	
	COLOR=vec4(0.0);
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	col+=circle((UV05*2.0),0.0)*additional_circle_add;


	col=step(cutoff,col);
	
	float final_mask=col;

	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));
	//COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
	/*	
	COLOR=vec4(island(UV-0.5,vec2(float(seed))));
	COLOR=vec4(circle((UV-0.5)*1.5,float(0.0)));
	COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
		*/
	//COLOR=vec4(vec3(         step(   turb(UV*30.1,3),0.3   )        ),1.0);
	//COLOR=vec4(vec3(         island((UV-vec2(0.5))*1.5,vec2(0163323.5))       ),1.0);
	//COLOR=vec4(vec3(      step(fbm(UV*10.0,8)   ,godotcon)      ),1.0);
	//COLOR=vec4(vec3(   step( turb(UV*10.0,8) ,godotcon) ),1.0);
	//COLOR=vec4(0.0);
	//COLOR+= step(  turb(UV*10.0,7)  , testowo2);
	
}

"

[sub_resource type="ShaderMaterial" id=269]
shader = SubResource( 90 )
shader_param/scale = Vector2( 256, 256 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.7366
shader_param/additional_circle_add = 0.0419
shader_param/circle_mul = 0.135
shader_param/init_add = 0.2
shader_param/noise_tile = 5.0
shader_param/noise_mul = 0.356375
shader_param/cutoff = 0.0553
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="Shader" id=87]
code = "shader_type canvas_item;


uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;
uniform float tunnel_roughness=0.5;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo2=0.5;
uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;



float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 uv05)
{
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((uv05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((uv05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm(st,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf(st,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb(st,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge(st,NUM_OCTAVES)*noise_mul;
	col+=circle((uv05*2.0),0.0)*additional_circle_add;
	return step(cutoff,col);
}

float my_tunel(vec2 UV_seed_tiled_scaled, vec2 UV_scaled)
{
	float is_tunnel=turb(UV_seed_tiled_scaled+
	
	(	vec2(fbm(UV_scaled*test2,NUM_OCTAVES),
		-fbm((UV_scaled*test2+vec2(-17.0,61.0)),NUM_OCTAVES))
	+	vec2(fbm((UV_scaled*test2+vec2(-7.0,51.0)),NUM_OCTAVES),
		fbm((UV_scaled*test2+vec2(-117.0,11.0)),NUM_OCTAVES))	)

	*tunnel_roughness,1);
	is_tunnel=pow(is_tunnel/**fbm(UV*4.0+2.0,1)*1.0*/,0.5);
	is_tunnel=float(is_tunnel>test3 && is_tunnel<test4);
	float final_mask=step((is_tunnel),cutoff);
	
	return final_mask;
	
}


float my_tunel_args(vec2 UV_seed_tiled_scaled, vec2 UV_scaled,float t2,float t3,float t4)
{
	
	

	//is_tunnel=turb((UV)*sca*noise_tile+seedf+fbm(UV05*sca,NUM_OCTAVES)*tunnel_roughness,1);
	
	float is_tunnel=turb(UV_seed_tiled_scaled+
	
	(	vec2(fbm(UV_scaled*t2,NUM_OCTAVES),
		-fbm((UV_scaled*t2+vec2(-17.0,61.0)),NUM_OCTAVES))
	+	vec2(fbm((UV_scaled*t2+vec2(-7.0,51.0)),NUM_OCTAVES),
		fbm((UV_scaled*t2+vec2(-117.0,11.0)),NUM_OCTAVES))	)

	*tunnel_roughness,1);
	is_tunnel=pow(is_tunnel/**fbm(UV*4.0+2.0,1)*1.0*/,0.5);
	is_tunnel=float(is_tunnel>t3 && is_tunnel<t4);
	float final_mask=step((is_tunnel),cutoff);
	
	return final_mask;
	
}


	
void fragment()
{
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 UV_seed=UV+seedf*0.1;
	vec2 sca=scale*0.01;
	vec2 UV_scaled=UV*sca;
	vec2 UV_seed_tiled_scaled=(UV*noise_tile*sca+seedf*0.1);
	vec2 UV_seed_scaled=UV_seed*sca;
	float ratio=scale.x/scale.y;

	COLOR=vec4(0.0);
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	
	COLOR=vec4(0.0);
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	col+=circle((UV05*2.0),0.0)*additional_circle_add;
	col=step(cutoff,col);
	
	float final_mask=col;

	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));

}

"

[sub_resource type="ShaderMaterial" id=270]
shader = SubResource( 87 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 3
shader_param/circle_type = 1
shader_param/circle_add = 0.454
shader_param/additional_circle_add = -0.06
shader_param/circle_mul = 1.6939
shader_param/init_add = 0.6
shader_param/noise_tile = 2.0
shader_param/noise_mul = 1.39428
shader_param/tunnel_roughness = 0.1769
shader_param/cutoff = 0.99
shader_param/NUM_OCTAVES = 1
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1

[sub_resource type="Shader" id=228]
code = "shader_type canvas_item;
uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo=0.5;
uniform float testowo2=0.5;

uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;

float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 offset)
{
	float col=circle((st*2.0),circle_add);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}
	
void fragment()
{
    vec3 color = vec3(0.0);
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 sca=scale*0.01;
	color=vec3(1.0,0.0,0.0);
	/*
	//dig difficulty
	vec2 st=(UV-0.5)*2.0;
	vec2 offset=vec2(float(seed));
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	color.g=(round(clamp(6.0-pow((round(col*12.0)),1.2),0.0,6.0))*8.0)/255.0;
	
	/*color=max(color,multiple_islands(UV_TEX,tex_size,10,0)*vec3(1.0,0.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,100)*vec3(1.0,8.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,200)*vec3(1.0,16.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,300)*vec3(1.0,24.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,400)*vec3(1.0,32.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,500)*vec3(1.0,40.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,600)*vec3(1.0,48.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,700)*vec3(1.0,56.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,800)*vec3(1.0,64.0/255.0,0.0));*/
//float empty=multiple_islands(UV_TEX,tex_size,100,900);
  //  COLOR= (1.0-empty)*vec4(color,1.0)+empty*vec4(0.0,0.0,0.0,0.0);

	//random points
//	vec2 pixel_UV=round(UV/TEXTURE_PIXEL_SIZE)*TEXTURE_PIXEL_SIZE;
//	COLOR=vec4(0.0,4.0,0.0,1.0)*random_places(pixel_UV,10.0,3);
/*
	if(color.r==1.0 && color.g==0.0 && color.b==0.0)
		if(enlarged_paths(UV,TEXTURE_PIXEL_SIZE,seed)==1.0)
			color=vec3(0.0,0.0,0.0);
	*/

		//lumps
	//color.rgb*=vec3(step(pow(fbm(UV*5.0*10.0+fbm(UV*100.0,2),2),15.0),0.0005));
	
	//river
	float is_river=pow(turb(fbm(UV_s*10.0,4)*0.1+fbm(UV_s*100.0,4)*0.01+UV_s,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_tunnel=pow(turb(fbm(UV_s*test2*10.0,4)*0.3+fbm(UV_s*test2*100.0,4)*0.01+UV_s*test2*2.0,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);

	//float is_cave=pow(turb(fbm(UV*test2*10.0,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2*2.0+float(seed),1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_cave=is_tunnel*15.0;
	is_cave+=float((fbm(UV_s*70.0+vec2(turb(UV_s*10.0,4),turb(UV_s*11.0,4))*1.095,1)-0.43*test3))*0.629*test4;
	if(is_cave<-0.016*test5 || is_tunnel<0.006)color=vec3(0.0,0.0,0.0);
	
	if( is_river<0.0015)
		color.r=((is_river/0.0015)+0.3);	
	if(step(is_river,0.0001)>0.0)
		color=vec3(1.0,240.0/255.0,0.0);
	
	//float is_river=pow(turb(fbm(UV*10.0*test2,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2+float(seed),1)*fbm(UV*test2+2.0,1)*1.0,1.9);


	color.rgb*=(1.0-island((UV-vec2(0.5,0.5))*10.0,vec2(float(seed))));
	
	if(color.r==0.0 && color.g==0.0 && color.b==0.0)
		COLOR=vec4(color,0.0);
	else
		COLOR=vec4(color,1.0);
		
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	
	
	COLOR=vec4(0.0);
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge((UV05)*noise_tile*sca-seedf,NUM_OCTAVES)*noise_mul;
	col+=circle((UV05*2.0),0.0)*additional_circle_add;


	col=step(cutoff,col);
	
	float final_mask=col;

	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));
	//COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
	/*	
	COLOR=vec4(island(UV-0.5,vec2(float(seed))));
	COLOR=vec4(circle((UV-0.5)*1.5,float(0.0)));
	COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
		*/
	//COLOR=vec4(vec3(         step(   turb(UV*30.1,3),0.3   )        ),1.0);
	//COLOR=vec4(vec3(         island((UV-vec2(0.5))*1.5,vec2(0163323.5))       ),1.0);
	//COLOR=vec4(vec3(      step(fbm(UV*10.0,8)   ,godotcon)      ),1.0);
	//COLOR=vec4(vec3(   step( turb(UV*10.0,8) ,godotcon) ),1.0);
	//COLOR=vec4(0.0);
	//COLOR+= step(  turb(UV*10.0,7)  , testowo2);
	
}

"

[sub_resource type="ShaderMaterial" id=271]
shader = SubResource( 228 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 2
shader_param/circle_type = 0
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 0.5
shader_param/circle_mul = 3.477
shader_param/init_add = 0.4
shader_param/noise_tile = 2.0
shader_param/noise_mul = 2.5
shader_param/cutoff = 0.7
shader_param/NUM_OCTAVES = 1
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1

[sub_resource type="ShaderMaterial" id=272]
shader = SubResource( 90 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = -1.046
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 6.195
shader_param/init_add = 0.0
shader_param/noise_tile = 3.945
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.35
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=234]
shader = SubResource( 90 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.7366
shader_param/additional_circle_add = 0.0419
shader_param/circle_mul = 0.135
shader_param/init_add = 0.2
shader_param/noise_tile = 5.0
shader_param/noise_mul = 0.356375
shader_param/cutoff = 0.0553
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=273]
shader = SubResource( 90 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.272
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.302
shader_param/noise_tile = 3.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.2
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=236]
shader = SubResource( 90 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.272
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.302
shader_param/noise_tile = 3.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.2
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=274]
shader = SubResource( 90 )
shader_param/scale = Vector2( 1060, 562 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.272
shader_param/additional_circle_add = 0.1387
shader_param/circle_mul = 1.2972
shader_param/init_add = 0.4641
shader_param/noise_tile = 1.0
shader_param/noise_mul = 1.6731
shader_param/cutoff = 0.6519
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=275]
shader = SubResource( 90 )
shader_param/scale = Vector2( 64, 64 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.1756
shader_param/additional_circle_add = 0.5908
shader_param/circle_mul = 1.047
shader_param/init_add = 0.2941
shader_param/noise_tile = 5.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.3572
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = false

[sub_resource type="ShaderMaterial" id=276]
shader = SubResource( 90 )
shader_param/scale = Vector2( 256, 256 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 1.0
shader_param/circle_mul = 1.0
shader_param/init_add = 0.2
shader_param/noise_tile = 4.0
shader_param/noise_mul = 3.0
shader_param/cutoff = 0.4
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4227858427
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=277]
shader = SubResource( 90 )
shader_param/scale = Vector2( 256, 256 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 0.2
shader_param/circle_mul = 1.0
shader_param/init_add = 0.1
shader_param/noise_tile = 4.0
shader_param/noise_mul = 3.0
shader_param/cutoff = 0.5
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4294967291
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=278]
shader = SubResource( 90 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 0
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 1.0
shader_param/circle_mul = 5.0
shader_param/init_add = 0.2
shader_param/noise_tile = 3.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.2
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4294967295
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=279]
shader = SubResource( 90 )
shader_param/scale = Vector2( 102.4, 102.4 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 0
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 1.0
shader_param/circle_mul = 5.0
shader_param/init_add = 0.2
shader_param/noise_tile = 3.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.2
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4294967295
shader_param/tile_scale = true

[sub_resource type="Shader" id=163]
code = "shader_type canvas_item;
uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo=0.5;
uniform float testowo2=0.5;

uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;
uniform bool tile_scale=true;

float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 offset)
{
	float col=circle((st*2.0),circle_add);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}
	
void fragment()
{
    vec3 color = vec3(0.0);
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 sca=scale*0.01;
	vec2 sca_norm=scale/max(scale.x,scale.y);
	color=vec3(1.0,0.0,0.0);
	/*
	//dig difficulty
	vec2 st=(UV-0.5)*2.0;
	vec2 offset=vec2(float(seed));
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	color.g=(round(clamp(6.0-pow((round(col*12.0)),1.2),0.0,6.0))*8.0)/255.0;
	
	/*color=max(color,multiple_islands(UV_TEX,tex_size,10,0)*vec3(1.0,0.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,100)*vec3(1.0,8.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,200)*vec3(1.0,16.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,300)*vec3(1.0,24.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,400)*vec3(1.0,32.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,500)*vec3(1.0,40.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,600)*vec3(1.0,48.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,700)*vec3(1.0,56.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,800)*vec3(1.0,64.0/255.0,0.0));*/
//float empty=multiple_islands(UV_TEX,tex_size,100,900);
  //  COLOR= (1.0-empty)*vec4(color,1.0)+empty*vec4(0.0,0.0,0.0,0.0);

	//random points
//	vec2 pixel_UV=round(UV/TEXTURE_PIXEL_SIZE)*TEXTURE_PIXEL_SIZE;
//	COLOR=vec4(0.0,4.0,0.0,1.0)*random_places(pixel_UV,10.0,3);
/*
	if(color.r==1.0 && color.g==0.0 && color.b==0.0)
		if(enlarged_paths(UV,TEXTURE_PIXEL_SIZE,seed)==1.0)
			color=vec3(0.0,0.0,0.0);
	*/

		//lumps
	//color.rgb*=vec3(step(pow(fbm(UV*5.0*10.0+fbm(UV*100.0,2),2),15.0),0.0005));
	
	//river
	float is_river=pow(turb(fbm(UV_s*10.0,4)*0.1+fbm(UV_s*100.0,4)*0.01+UV_s,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_tunnel=pow(turb(fbm(UV_s*test2*10.0,4)*0.3+fbm(UV_s*test2*100.0,4)*0.01+UV_s*test2*2.0,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);

	//float is_cave=pow(turb(fbm(UV*test2*10.0,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2*2.0+float(seed),1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_cave=is_tunnel*15.0;
	is_cave+=float((fbm(UV_s*70.0+vec2(turb(UV_s*10.0,4),turb(UV_s*11.0,4))*1.095,1)-0.43*test3))*0.629*test4;
	if(is_cave<-0.016*test5 || is_tunnel<0.006)color=vec3(0.0,0.0,0.0);
	
	if( is_river<0.0015)
		color.r=((is_river/0.0015)+0.3);	
	if(step(is_river,0.0001)>0.0)
		color=vec3(1.0,240.0/255.0,0.0);
	
	//float is_river=pow(turb(fbm(UV*10.0*test2,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2+float(seed),1)*fbm(UV*test2+2.0,1)*1.0,1.9);


	color.rgb*=(1.0-island((UV-vec2(0.5,0.5))*10.0,vec2(float(seed))));
	
	if(color.r==0.0 && color.g==0.0 && color.b==0.0)
		COLOR=vec4(color,0.0);
	else
		COLOR=vec4(color,1.0);
		
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	
	
	COLOR=vec4(0.0);
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	col+=circle((UV05*2.0),0.0)*additional_circle_add;


	col=step(cutoff,col);
	
	float final_mask=col;

	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));
	//COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
	/*	
	COLOR=vec4(island(UV-0.5,vec2(float(seed))));
	COLOR=vec4(circle((UV-0.5)*1.5,float(0.0)));
	COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
		*/
	//COLOR=vec4(vec3(         step(   turb(UV*30.1,3),0.3   )        ),1.0);
	//COLOR=vec4(vec3(         island((UV-vec2(0.5))*1.5,vec2(0163323.5))       ),1.0);
	//COLOR=vec4(vec3(      step(fbm(UV*10.0,8)   ,godotcon)      ),1.0);
	//COLOR=vec4(vec3(   step( turb(UV*10.0,8) ,godotcon) ),1.0);
	//COLOR=vec4(0.0);
	//COLOR+= step(  turb(UV*10.0,7)  , testowo2);
	
}

"

[sub_resource type="ShaderMaterial" id=243]
shader = SubResource( 163 )
shader_param/scale = Vector2( 200, 200 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.5
shader_param/additional_circle_add = 1.5
shader_param/circle_mul = 1.0
shader_param/init_add = 0.302
shader_param/noise_tile = 4.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.3
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="Shader" id=165]
code = "shader_type canvas_item;
uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo=0.5;
uniform float testowo2=0.5;

uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;
uniform bool tile_scale=true;

float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 offset)
{
	float col=circle((st*2.0),circle_add);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}
	
void fragment()
{
    vec3 color = vec3(0.0);
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 sca=scale*0.01;
	vec2 sca_norm=scale/max(scale.x,scale.y);
	color=vec3(1.0,0.0,0.0);
	/*
	//dig difficulty
	vec2 st=(UV-0.5)*2.0;
	vec2 offset=vec2(float(seed));
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	color.g=(round(clamp(6.0-pow((round(col*12.0)),1.2),0.0,6.0))*8.0)/255.0;
	
	/*color=max(color,multiple_islands(UV_TEX,tex_size,10,0)*vec3(1.0,0.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,100)*vec3(1.0,8.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,200)*vec3(1.0,16.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,300)*vec3(1.0,24.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,400)*vec3(1.0,32.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,500)*vec3(1.0,40.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,600)*vec3(1.0,48.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,700)*vec3(1.0,56.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,800)*vec3(1.0,64.0/255.0,0.0));*/
//float empty=multiple_islands(UV_TEX,tex_size,100,900);
  //  COLOR= (1.0-empty)*vec4(color,1.0)+empty*vec4(0.0,0.0,0.0,0.0);

	//random points
//	vec2 pixel_UV=round(UV/TEXTURE_PIXEL_SIZE)*TEXTURE_PIXEL_SIZE;
//	COLOR=vec4(0.0,4.0,0.0,1.0)*random_places(pixel_UV,10.0,3);
/*
	if(color.r==1.0 && color.g==0.0 && color.b==0.0)
		if(enlarged_paths(UV,TEXTURE_PIXEL_SIZE,seed)==1.0)
			color=vec3(0.0,0.0,0.0);
	*/

		//lumps
	//color.rgb*=vec3(step(pow(fbm(UV*5.0*10.0+fbm(UV*100.0,2),2),15.0),0.0005));
	
	//river
	float is_river=pow(turb(fbm(UV_s*10.0,4)*0.1+fbm(UV_s*100.0,4)*0.01+UV_s,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_tunnel=pow(turb(fbm(UV_s*test2*10.0,4)*0.3+fbm(UV_s*test2*100.0,4)*0.01+UV_s*test2*2.0,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);

	//float is_cave=pow(turb(fbm(UV*test2*10.0,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2*2.0+float(seed),1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_cave=is_tunnel*15.0;
	is_cave+=float((fbm(UV_s*70.0+vec2(turb(UV_s*10.0,4),turb(UV_s*11.0,4))*1.095,1)-0.43*test3))*0.629*test4;
	if(is_cave<-0.016*test5 || is_tunnel<0.006)color=vec3(0.0,0.0,0.0);
	
	if( is_river<0.0015)
		color.r=((is_river/0.0015)+0.3);	
	if(step(is_river,0.0001)>0.0)
		color=vec3(1.0,240.0/255.0,0.0);
	
	//float is_river=pow(turb(fbm(UV*10.0*test2,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2+float(seed),1)*fbm(UV*test2+2.0,1)*1.0,1.9);


	color.rgb*=(1.0-island((UV-vec2(0.5,0.5))*10.0,vec2(float(seed))));
	
	if(color.r==0.0 && color.g==0.0 && color.b==0.0)
		COLOR=vec4(color,0.0);
	else
		COLOR=vec4(color,1.0);
		
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	
	
	COLOR=vec4(0.0);
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	col+=circle((UV05*2.0),0.0)*additional_circle_add;


	col=step(cutoff,col);
	
	float final_mask=col;

	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));
	//COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
	/*	
	COLOR=vec4(island(UV-0.5,vec2(float(seed))));
	COLOR=vec4(circle((UV-0.5)*1.5,float(0.0)));
	COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
		*/
	//COLOR=vec4(vec3(         step(   turb(UV*30.1,3),0.3   )        ),1.0);
	//COLOR=vec4(vec3(         island((UV-vec2(0.5))*1.5,vec2(0163323.5))       ),1.0);
	//COLOR=vec4(vec3(      step(fbm(UV*10.0,8)   ,godotcon)      ),1.0);
	//COLOR=vec4(vec3(   step( turb(UV*10.0,8) ,godotcon) ),1.0);
	//COLOR=vec4(0.0);
	//COLOR+= step(  turb(UV*10.0,7)  , testowo2);
	
}

"

[sub_resource type="ShaderMaterial" id=267]
shader = SubResource( 165 )
shader_param/scale = Vector2( 200, 200 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 2.0
shader_param/circle_mul = 1.0
shader_param/init_add = 0.6
shader_param/noise_tile = 1.6
shader_param/noise_mul = 2.0
shader_param/cutoff = 1.0
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=280]
shader = SubResource( 165 )
shader_param/scale = Vector2( 32, 32 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 2.0
shader_param/circle_mul = 1.0
shader_param/init_add = 0.6
shader_param/noise_tile = 1.6
shader_param/noise_mul = 2.0
shader_param/cutoff = 1.0
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=281]
shader = SubResource( 90 )
shader_param/scale = Vector2( 200, 200 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.272
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.302
shader_param/noise_tile = 3.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.3
shader_param/NUM_OCTAVES = 3
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=288]
shader = SubResource( 165 )
shader_param/scale = Vector2( 200, 200 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 2.0
shader_param/circle_mul = 1.0
shader_param/init_add = 0.6
shader_param/noise_tile = 1.6
shader_param/noise_mul = 2.0
shader_param/cutoff = 1.0
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="Shader" id=167]
code = "shader_type canvas_item;
uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo=0.5;
uniform float testowo2=0.5;

uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;
uniform bool tile_scale=true;

float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 offset)
{
	float col=circle((st*2.0),circle_add);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}
	
void fragment()
{
    vec3 color = vec3(0.0);
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 sca=scale*0.01;
	vec2 sca_norm=scale/max(scale.x,scale.y);
	color=vec3(1.0,0.0,0.0);
	/*
	//dig difficulty
	vec2 st=(UV-0.5)*2.0;
	vec2 offset=vec2(float(seed));
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	color.g=(round(clamp(6.0-pow((round(col*12.0)),1.2),0.0,6.0))*8.0)/255.0;
	
	/*color=max(color,multiple_islands(UV_TEX,tex_size,10,0)*vec3(1.0,0.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,100)*vec3(1.0,8.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,200)*vec3(1.0,16.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,300)*vec3(1.0,24.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,400)*vec3(1.0,32.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,500)*vec3(1.0,40.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,600)*vec3(1.0,48.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,700)*vec3(1.0,56.0/255.0,0.0));
	color=max(color,multiple_islands(UV_TEX,tex_size,10,800)*vec3(1.0,64.0/255.0,0.0));*/
//float empty=multiple_islands(UV_TEX,tex_size,100,900);
  //  COLOR= (1.0-empty)*vec4(color,1.0)+empty*vec4(0.0,0.0,0.0,0.0);

	//random points
//	vec2 pixel_UV=round(UV/TEXTURE_PIXEL_SIZE)*TEXTURE_PIXEL_SIZE;
//	COLOR=vec4(0.0,4.0,0.0,1.0)*random_places(pixel_UV,10.0,3);
/*
	if(color.r==1.0 && color.g==0.0 && color.b==0.0)
		if(enlarged_paths(UV,TEXTURE_PIXEL_SIZE,seed)==1.0)
			color=vec3(0.0,0.0,0.0);
	*/

		//lumps
	//color.rgb*=vec3(step(pow(fbm(UV*5.0*10.0+fbm(UV*100.0,2),2),15.0),0.0005));
	
	//river
	float is_river=pow(turb(fbm(UV_s*10.0,4)*0.1+fbm(UV_s*100.0,4)*0.01+UV_s,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_tunnel=pow(turb(fbm(UV_s*test2*10.0,4)*0.3+fbm(UV_s*test2*100.0,4)*0.01+UV_s*test2*2.0,1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);

	//float is_cave=pow(turb(fbm(UV*test2*10.0,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2*2.0+float(seed),1)/**fbm(UV*4.0+2.0,1)*1.0*/,1.9);
	float is_cave=is_tunnel*15.0;
	is_cave+=float((fbm(UV_s*70.0+vec2(turb(UV_s*10.0,4),turb(UV_s*11.0,4))*1.095,1)-0.43*test3))*0.629*test4;
	if(is_cave<-0.016*test5 || is_tunnel<0.006)color=vec3(0.0,0.0,0.0);
	
	if( is_river<0.0015)
		color.r=((is_river/0.0015)+0.3);	
	if(step(is_river,0.0001)>0.0)
		color=vec3(1.0,240.0/255.0,0.0);
	
	//float is_river=pow(turb(fbm(UV*10.0*test2,4)*0.3+fbm(UV*100.0*test2,4)*0.01+UV*test2+float(seed),1)*fbm(UV*test2+2.0,1)*1.0,1.9);


	color.rgb*=(1.0-island((UV-vec2(0.5,0.5))*10.0,vec2(float(seed))));
	
	if(color.r==0.0 && color.g==0.0 && color.b==0.0)
		COLOR=vec4(color,0.0);
	else
		COLOR=vec4(color,1.0);
		
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	
	
	COLOR=vec4(0.0);
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((UV05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge((UV05)*noise_tile*(sca*float(tile_scale)+float(!tile_scale)*sca_norm)-seedf,NUM_OCTAVES)*noise_mul;
	col+=circle((UV05*2.0),0.0)*additional_circle_add;


	col=step(cutoff,col);
	
	float final_mask=col;

	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));
	//COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
	/*	
	COLOR=vec4(island(UV-0.5,vec2(float(seed))));
	COLOR=vec4(circle((UV-0.5)*1.5,float(0.0)));
	COLOR=vec4(island2(UV-0.5,vec2(float(seed))));
		*/
	//COLOR=vec4(vec3(         step(   turb(UV*30.1,3),0.3   )        ),1.0);
	//COLOR=vec4(vec3(         island((UV-vec2(0.5))*1.5,vec2(0163323.5))       ),1.0);
	//COLOR=vec4(vec3(      step(fbm(UV*10.0,8)   ,godotcon)      ),1.0);
	//COLOR=vec4(vec3(   step( turb(UV*10.0,8) ,godotcon) ),1.0);
	//COLOR=vec4(0.0);
	//COLOR+= step(  turb(UV*10.0,7)  , testowo2);
	
}

"

[sub_resource type="ShaderMaterial" id=283]
shader = SubResource( 167 )
shader_param/scale = Vector2( 128, 128 )
shader_param/seed = 3911
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 0.5
shader_param/circle_mul = 2.0
shader_param/init_add = 0.302
shader_param/noise_tile = 2.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.3
shader_param/NUM_OCTAVES = 3
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=284]
shader = SubResource( 90 )
shader_param/scale = Vector2( 100, 100 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.8
shader_param/additional_circle_add = 0.4
shader_param/circle_mul = 0.6
shader_param/init_add = 0.0
shader_param/noise_tile = 3.0
shader_param/noise_mul = 3.0
shader_param/cutoff = 0.4
shader_param/NUM_OCTAVES = 3
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4093640703
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=285]
shader = SubResource( 167 )
shader_param/scale = Vector2( 40, 40 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 0.5
shader_param/circle_mul = 2.0
shader_param/init_add = 0.302
shader_param/noise_tile = 3.0
shader_param/noise_mul = 1.0
shader_param/cutoff = 0.3
shader_param/NUM_OCTAVES = 3
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4227858431
shader_param/tile_scale = true

[sub_resource type="ShaderMaterial" id=286]
shader = SubResource( 90 )
shader_param/scale = Vector2( 100, 100 )
shader_param/seed = 3112
shader_param/noise_type = 0
shader_param/circle_type = 1
shader_param/circle_add = 0.0
shader_param/additional_circle_add = 0.2
shader_param/circle_mul = 0.4
shader_param/init_add = 0.0
shader_param/noise_tile = 3.0
shader_param/noise_mul = 8.0
shader_param/cutoff = 0.6
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.0
shader_param/test2 = 1.0
shader_param/test3 = 1.0
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4227858431
shader_param/tile_scale = true

[sub_resource type="ViewportTexture" id=289]

[sub_resource type="Shader" id=29]
code = "shader_type canvas_item;


uniform vec2 scale =vec2(100.0,100.0);
uniform int seed : hint_range(-10000,10000)=1234;
uniform int noise_type : hint_range(0,3)=0;
uniform int circle_type : hint_range(0,1)=0;
uniform float circle_add=0.0;
uniform float additional_circle_add=0.0;
uniform float circle_mul=1.0;
uniform float init_add=0.0;
uniform float noise_tile=3.0;
uniform float noise_mul=1.0;
uniform float tunnel_roughness=0.5;

uniform float cutoff=0.3;


uniform int NUM_OCTAVES: hint_range(1,8)= 4 ;
uniform float test1=1.0;
uniform float test2=1.0;
uniform float test3=1.0;
uniform float test4=1.0;
uniform float test5=1.0;
uniform float godotcon=0.5;
uniform float testowo2=0.5;
uniform sampler2D map :hint_default_black;
uniform int material_mask=-1;



float random (in vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);

}
float random2 (in vec2 p) {
    return fract(sin(dot(p.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


float fbm ( in vec2 _st, int fractal_octaves) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbmf(vec2 p,int notoctaves)
{
	mat2 m2 = mat2(vec2(0.8,-0.6),vec2(0.6,0.8));
    float f = 0.0;
    f += 0.5000*noise( p ); p = m2*p*2.02;
    f += 0.2500*noise( p ); p = m2*p*2.03;
    f += 0.1250*noise( p ); p = m2*p*2.01;
    f += 0.0625*noise( p );

    return f/0.9375;
}
float turb(in vec2 _st, int fractal_octaves)
{
	float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(vec2(cos(0.5), sin(0.5)),vec2(-sin(0.5), cos(0.50)));
    for (int i = 0; i < fractal_octaves; ++i) {
        v += a * abs(snoise(_st));
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float ridge(in vec2 st, int fractal_octaves)
{

    return 1.0-turb(st,fractal_octaves);
}

float circle(in vec2 st, float expand)
{
	float r = min(distance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float cDistance(vec2 a, vec2 b)
{
	vec2 d = a - b;
	d = abs(d);
	return max(d.x, d.y);
}

float rect_circle(in vec2 st, float expand)
{
	float r = min(cDistance(vec2(0.0), st),1.0);
	return mix(1.0, 0.0, (r - expand) / (1.0 - expand));
}

float island(vec2 st,vec2 offset)
{
	float col=circle((st),0.0);
	col*=fbm(st*3.0-offset,4);
	col=step(0.3,col);
	return col;
}

float multiple_islands(vec2 UV_TEX,vec2 tex_size,int count, int add_seed)
{
	float is_res=0.0;
 	for( int i =0;i<count;++i)
	{
		vec2 ran_pos=vec2(0.0);
		ran_pos.x=random(vec2(float((i+1+seed+add_seed))));
		ran_pos.y=random(vec2(float((i+1+seed+add_seed)+1)));
		ran_pos*=tex_size;
		float ran_scale=random(ran_pos+vec2(float(i+seed+add_seed+5)));
		is_res+=island((UV_TEX-ran_pos)*0.01/(1.0+ran_scale*4.0),vec2(random(ran_pos)*3521.0))*1.2;
	}
	return min(1.0,is_res);
}

float random_places(vec2 UV_TEX,float density,int add_seed)
{
	
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	float co=fbm(pixel_UV*density,4);
	float maxi = 0.0;
	float R=8.0;
	// there are more efficient algorithms than this
	for (float yn = -R; yn <= R ; yn+=1.0) {
		for (float xn = -R; xn <= R ; xn+=1.0) {
			float val = fbm(pixel_UV*density+vec2(xn,yn)*0.001*density,4);
			if (val > maxi) { maxi = val; }
		}
	}
	if (co == maxi) 
		return 1.0;
	else
		return 0.0;
}

float paths(vec2 UV_TEX,int add_seed)
{
	vec2 pixel_UV=UV_TEX+vec2(float((seed+add_seed)/1000),float((seed+add_seed) %1000));
	return (abs(pow(fbm(fbm(pixel_UV*100.0,4)*0.15+pixel_UV*20.0+186.0,2),1.00)-test1)<0.001)?1.0:0.0;
}

float enlarged_paths(vec2 UV_TEX,vec2 tps,int add_seed)
{
	
	bool not_important=true;
	float range=15.0;
	float count=0.0;
	for(float i=-range;i<range;i+=1.0)
		for(float j=-range;j<range;j+=1.0)
		{
			float col=paths(UV_TEX+vec2(i,j)*tps, add_seed);
			//vec3 col=texture(TEXTURE,UV+vec2(i,j)*TEXTURE_PIXEL_SIZE).rgb;
			if(length(vec2(i,j))<range &&col>0.5)
				count+=1.0;
		}
	if(not_important && count>1.0)
		return 1.0;
	else
		return 0.0;
}


float island2(vec2 st,vec2 uv05)
{
	float col=0.0;
	if (circle_type==0)
		col=clamp(rect_circle((uv05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
	if (circle_type==1)
		col=clamp(circle((uv05*2.0),circle_add)*circle_mul+init_add,0.0,1.0);
		
		
	if (noise_type==0)
		col*=fbm(st,NUM_OCTAVES)*noise_mul;
	if (noise_type==1)
		col*=fbmf(st,NUM_OCTAVES)*noise_mul;
	if (noise_type==2)
		col*=turb(st,NUM_OCTAVES)*noise_mul;
	if (noise_type==3)
		col*=ridge(st,NUM_OCTAVES)*noise_mul;
	col+=circle((uv05*2.0),0.0)*additional_circle_add;
	return step(cutoff,col);
}

float my_tunel(vec2 UV_seed_tiled_scaled, vec2 UV_scaled)
{
	float is_tunnel=turb(UV_seed_tiled_scaled+
	
	(	vec2(fbm(UV_scaled*test2,NUM_OCTAVES),
		-fbm((UV_scaled*test2+vec2(-17.0,61.0)),NUM_OCTAVES))
	+	vec2(fbm((UV_scaled*test2+vec2(-7.0,51.0)),NUM_OCTAVES),
		fbm((UV_scaled*test2+vec2(-117.0,11.0)),NUM_OCTAVES))	)

	*tunnel_roughness,1);
	is_tunnel=pow(is_tunnel/**fbm(UV*4.0+2.0,1)*1.0*/,0.5);
	is_tunnel=float(is_tunnel>test3 && is_tunnel<test4);
	float final_mask=step((is_tunnel),cutoff);
	
	return final_mask;
	
}


float my_tunel_args(vec2 UV_seed_tiled_scaled, vec2 UV_scaled,float t2,float t3,float t4)
{
	
	

	//is_tunnel=turb((UV)*sca*noise_tile+seedf+fbm(UV05*sca,NUM_OCTAVES)*tunnel_roughness,1);
	
	float is_tunnel=turb(UV_seed_tiled_scaled+
	
	(	vec2(fbm(UV_scaled*t2,NUM_OCTAVES),
		-fbm((UV_scaled*t2+vec2(-17.0,61.0)),NUM_OCTAVES))
	+	vec2(fbm((UV_scaled*t2+vec2(-7.0,51.0)),NUM_OCTAVES),
		fbm((UV_scaled*t2+vec2(-117.0,11.0)),NUM_OCTAVES))	)

	*tunnel_roughness,1);
	is_tunnel=pow(is_tunnel/**fbm(UV*4.0+2.0,1)*1.0*/,0.5);
	is_tunnel=float(is_tunnel>t3 && is_tunnel<t4);
	float final_mask=step((is_tunnel),cutoff);
	
	return final_mask;
	
}


	
void fragment()
{
	vec2 UV_TEX=UV/TEXTURE_PIXEL_SIZE;
	vec2 tex_size=vec2(textureSize(TEXTURE,0));
	vec2 pixel_UV=UV_TEX+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV_s=UV+vec2(float((seed)/1000),float((seed) %1000));
	vec2 UV05=UV-0.5;
	float seedf=float(seed);
	vec2 UV_seed=UV+seedf*0.1;
	vec2 sca=scale*0.01;
	vec2 UV_scaled=UV*sca;
	vec2 UV_seed_tiled_scaled=(UV*noise_tile*sca+seedf*0.1);
	vec2 UV_seed_scaled=UV_seed*sca;
	float ratio=scale.x/scale.y;

	COLOR=vec4(0.0);
	vec4 map_smp=texelFetch(map,ivec2(vec2(UV.x,UV.y)*scale),0);
	int cur_res=int((map_smp.g*255.0+0.5));
	if(map_smp.x>0.01 || map_smp.y>0.01|| map_smp.z>0.01)
	{
		if((1<<cur_res & material_mask)==0)
			discard;
	}
	float final_mask=my_tunel(UV_seed_tiled_scaled,UV_scaled);
	
	
	
	COLOR=vec4(vec3(final_mask),final_mask);
	COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));

}

"

[sub_resource type="ShaderMaterial" id=43]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = 4269
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.1
shader_param/noise_mul = 0.899
shader_param/tunnel_roughness = 0.1702
shader_param/cutoff = 0.2
shader_param/NUM_OCTAVES = 5
shader_param/test1 = 1.0
shader_param/test2 = 0.5
shader_param/test3 = 0.3
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = -1

[sub_resource type="ShaderMaterial" id=68]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = -407
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.108
shader_param/noise_mul = 0.9294
shader_param/tunnel_roughness = 0.5604
shader_param/cutoff = 0.493458
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.76773
shader_param/test2 = 0.385483
shader_param/test3 = -0.0061
shader_param/test4 = 0.4446
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4

[sub_resource type="ShaderMaterial" id=196]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = -1508
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.1
shader_param/noise_mul = 0.899
shader_param/tunnel_roughness = 0.1702
shader_param/cutoff = 0.2
shader_param/NUM_OCTAVES = 5
shader_param/test1 = 1.0
shader_param/test2 = 0.5
shader_param/test3 = 0.3
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4093640695

[sub_resource type="ShaderMaterial" id=197]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = -6572
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.108
shader_param/noise_mul = 0.9294
shader_param/tunnel_roughness = 0.5604
shader_param/cutoff = 0.493458
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.76773
shader_param/test2 = 0.385483
shader_param/test3 = -0.0061
shader_param/test4 = 0.4446
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 2

[sub_resource type="ShaderMaterial" id=36]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = 3499
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.1733
shader_param/noise_mul = 0.899
shader_param/tunnel_roughness = 1.0
shader_param/cutoff = 0.9641
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 0.0
shader_param/test2 = 0.3398
shader_param/test3 = 0.1693
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4294967291

[sub_resource type="ShaderMaterial" id=37]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = -6426
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.108
shader_param/noise_mul = 0.9294
shader_param/tunnel_roughness = 0.5604
shader_param/cutoff = 0.9059
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.7742
shader_param/test2 = 0.3879
shader_param/test3 = -0.0061
shader_param/test4 = 0.4935
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 134217728

[sub_resource type="ShaderMaterial" id=54]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = 7112
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.1733
shader_param/noise_mul = 0.899
shader_param/tunnel_roughness = 1.0
shader_param/cutoff = 0.9641
shader_param/NUM_OCTAVES = 4
shader_param/test1 = 0.0
shader_param/test2 = 0.3398
shader_param/test3 = 0.1693
shader_param/test4 = 1.0
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 4160749563

[sub_resource type="ShaderMaterial" id=55]
shader = SubResource( 29 )
shader_param/scale = Vector2( 2048, 2048 )
shader_param/seed = -749
shader_param/noise_type = 3
shader_param/circle_type = 0
shader_param/circle_add = 0.92
shader_param/additional_circle_add = 0.0
shader_param/circle_mul = 2.0
shader_param/init_add = 0.0
shader_param/noise_tile = 0.108
shader_param/noise_mul = 0.9294
shader_param/tunnel_roughness = 0.5604
shader_param/cutoff = 0.9059
shader_param/NUM_OCTAVES = 2
shader_param/test1 = 1.7742
shader_param/test2 = 0.3879
shader_param/test3 = -0.0061
shader_param/test4 = 0.4935
shader_param/test5 = 1.0
shader_param/godotcon = 0.5
shader_param/testowo2 = 0.5
shader_param/material_mask = 8

[sub_resource type="Shader" id=129]
code = "// NOTE: Shader automatically converted from Godot Engine 3.5.stable's CanvasItemMaterial.

shader_type canvas_item;
render_mode blend_mix;

uniform int material_mask=2;
uniform int range=10;
uniform float percentage=0.7;




void fragment()
{
	
	COLOR=vec4(0.0);
	int how_many=0;
	vec4 real_smp=texelFetch(TEXTURE,ivec2(vec2(UV.x,UV.y)*vec2(textureSize(TEXTURE,0))),0);
	int real_cur_res=int((real_smp.g*255.0+0.5));
	for(int i=-range; i<=range;++i)
		for(int j=-range; j<=range;++j)	
	{
		
		vec4 map_smp=texelFetch(TEXTURE,ivec2(i,j)+ivec2(vec2(UV.x,UV.y)*vec2(textureSize(TEXTURE,0))),0);
	//	map_smp=texture(TEXTURE,UV);
		int cur_res=int((map_smp.g*255.0+0.5));
		{
			if(((1<<cur_res) & material_mask)==0)
				how_many++;
		}
	}	
	
	
	
	if (float(how_many)<percentage*float((2*range+1)*(2*range+1) ))
		COLOR=vec4(1.0);
	//COLOR=vec4(vec3(final_mask),final_mask);
	//COLOR=clamp(COLOR,vec4(0.0),vec4(1.0));
	
}"

[sub_resource type="ShaderMaterial" id=131]
shader = SubResource( 129 )
shader_param/material_mask = 4
shader_param/range = 6
shader_param/percentage = 0.9

[sub_resource type="ShaderMaterial" id=198]
shader = SubResource( 129 )
shader_param/material_mask = 2
shader_param/range = 6
shader_param/percentage = 0.9

[sub_resource type="ShaderMaterial" id=132]
shader = SubResource( 129 )
shader_param/material_mask = 8
shader_param/range = 3
shader_param/percentage = 0.9

[sub_resource type="ShaderMaterial" id=130]
shader = SubResource( 129 )
shader_param/material_mask = 134217728
shader_param/range = 3
shader_param/percentage = 0.9

[sub_resource type="ShaderMaterial" id=134]
shader = SubResource( 129 )
shader_param/material_mask = 33554432
shader_param/range = 12
shader_param/percentage = 0.6

[node name="root" type="Node2D"]
script = ExtResource( 1 )

[node name="SubViewport" type="SubViewport" parent="."]
unique_name_in_owner = true
size = Vector2( 2048, 2048 )
own_world = true
transparent_bg = true
hdr = false
disable_3d = true
usage = 0
render_target_v_flip = true
render_target_clear_mode = 1
render_target_update_mode = 3

[node name="Sprite2D" type="Sprite2D" parent="."]
visible = false
modulate = Color( 0, 0, 0, 1 )
scale = Vector2( 4192, 4192 )
z_index = -1091
texture = ExtResource( 6 )
centered = false

[node name="NotPixelMap" type="PixelMap" parent="."]
unique_name_in_owner = true
process_priority = 100
z_index = -573
material_data = SubResource( 106 )
script = ExtResource( 9 )
custom_materials = [ null, null, null, null, null, null ]

[node name="PixelMapPhysics" type="PixelMapPhysics" parent="NotPixelMap"]

[node name="good_rects_presets" type="Node2D" parent="."]
unique_name_in_owner = true
self_modulate = Color( 0, 0.439216, 0.478431, 0.623529 )
z_index = 681

[node name="tunnels" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -649, -365 )
script = ExtResource( 22 )
min_size = Vector2( 256, 256 )
variable_size = 0
size = Vector2( 256, 256 )
probability = 150
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="good_rects_presets/tunnels"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 256, 256 )
texture = ExtResource( 4 )
centered = false

[node name="TextureRect" parent="good_rects_presets/tunnels/preview" instance=ExtResource( 18 )]
material = SubResource( 268 )
offset_right = 32.0
offset_bottom = 32.0
scale = Vector2( 0.03125, 0.03125 )
material_type = 25

[node name="full_resource_blob" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -353, -365 )
script = ExtResource( 16 )
variable_size = 0.5
max_size = Vector2( 256, 256 )
size = Vector2( 256, 256 )
remove_if_lava_rect = null

[node name="preview" type="Sprite2D" parent="good_rects_presets/full_resource_blob"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 256, 256 )
texture = ExtResource( 4 )
centered = false

[node name="full_resource_blob" type="Sprite2D" parent="good_rects_presets/full_resource_blob/preview"]
modulate = Color( 0.384314, 0.180392, 0.0980392, 1 )
material = SubResource( 269 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 3
my_seed = 3911

[node name="resource_holes" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 1, -365 )
script = ExtResource( 8 )
variable_size = 0.5
max_size = Vector2( 256, 256 )
size = Vector2( 128, 128 )

[node name="preview" type="Sprite2D" parent="good_rects_presets/resource_holes"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="resource_holes" type="Sprite2D" parent="good_rects_presets/resource_holes/preview"]
modulate = Color( 1, 0.5, 1, 1 )
material = SubResource( 270 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 27
my_seed = 3911

[node name="resource_spray" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 209, -365 )
script = ExtResource( 16 )
variable_size = 0.5
max_size = Vector2( 256, 256 )
size = Vector2( 128, 128 )
remove_if_lava_rect = null

[node name="preview" type="Sprite2D" parent="good_rects_presets/resource_spray"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="resource_spray" type="Sprite2D" parent="good_rects_presets/resource_spray/preview"]
modulate = Color( 0.384314, 0.180392, 0.0980392, 1 )
material = SubResource( 271 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 3
my_seed = 3911

[node name="resource_chunks" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 387, -365 )
script = ExtResource( 16 )
variable_size = 0.5
max_size = Vector2( 256, 256 )
size = Vector2( 128, 128 )
remove_if_lava_rect = null

[node name="preview" type="Sprite2D" parent="good_rects_presets/resource_chunks"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="resource_chunks" type="Sprite2D" parent="good_rects_presets/resource_chunks/preview"]
modulate = Color( 0.384314, 0.180392, 0.0980392, 1 )
material = SubResource( 272 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 3
my_seed = 3911

[node name="mine_in_metal" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -164, -365 )
script = ExtResource( 11 )
variable_size = 0
max_size = Vector2( 256, 256 )
size = Vector2( 128, 128 )
probability = 5
distance_requirements = [ Vector3( 0, 400, 1 ), Vector3( 400, 700, 1 ), Vector3( 700, 1200, 3 ) ]

[node name="preview" type="Sprite2D" parent="good_rects_presets/mine_in_metal"]
self_modulate = Color( 0.392157, 0.929412, 0.419608, 0.501961 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="mine_in_metal" type="Sprite2D" parent="good_rects_presets/mine_in_metal/preview"]
modulate = Color( 0.384314, 0.180392, 0.0980392, 1 )
material = SubResource( 234 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 3
my_seed = 3911

[node name="monster_cave" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 587, -365 )
script = ExtResource( 22 )
min_size = Vector2( 64, 64 )
variable_size = 0
max_size = Vector2( 256, 256 )
size = Vector2( 128, 128 )
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="good_rects_presets/monster_cave"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="monster_cave" type="Sprite2D" parent="good_rects_presets/monster_cave/preview"]
material = SubResource( 273 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="rich_swarm_cave" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.882353, 0.392157, 0.929412, 0.501961 )
position = Vector2( 770, -365 )
script = ExtResource( 13 )
variable_size = 0
max_size = Vector2( 128, 128 )
size = Vector2( 128, 128 )
probability = 20
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="good_rects_presets/rich_swarm_cave"]
self_modulate = Color( 0.866667, 0.392157, 0.929412, 0.501961 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="rich_swarm_cave" type="Sprite2D" parent="good_rects_presets/rich_swarm_cave/preview"]
material = SubResource( 236 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="monster_cavelike_big" type="Node2D" parent="good_rects_presets"]
visible = false
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 387, 529 )
script = ExtResource( 8 )
min_size = Vector2( 256, 256 )
size = Vector2( 1060, 562 )
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="good_rects_presets/monster_cavelike_big"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 1060, 562 )
texture = ExtResource( 4 )
centered = false

[node name="monster_cavelike_big" type="Sprite2D" parent="good_rects_presets/monster_cavelike_big/preview"]
material = SubResource( 274 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="arena_full_circle" type="Node2D" parent="good_rects_presets"]
visible = false
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 29, 448 )
script = ExtResource( 8 )
min_size = Vector2( 64, 64 )
size = Vector2( 64, 64 )
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="good_rects_presets/arena_full_circle"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 64, 64 )
texture = ExtResource( 4 )
centered = false

[node name="arena_full_circle" type="Sprite2D" parent="good_rects_presets/arena_full_circle/preview"]
material = SubResource( 275 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="outlined_blob" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 976, -365 )
script = ExtResource( 8 )
min_size = Vector2( 64, 64 )
max_size = Vector2( 256, 256 )
size = Vector2( 256, 256 )
probability = 20

[node name="preview" type="Sprite2D" parent="good_rects_presets/outlined_blob"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 256, 256 )
texture = ExtResource( 4 )
centered = false

[node name="resource_blob_medium_outline" type="Sprite2D" parent="good_rects_presets/outlined_blob/preview"]
modulate = Color( 0, 0, 1, 1 )
material = SubResource( 276 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 26
mask = 4227858427
my_seed = 3112
use_same_seed = true

[node name="resource_blob_medium_inside2" type="Sprite2D" parent="good_rects_presets/outlined_blob/preview"]
modulate = Color( 1, 0.5, 1, 1 )
material = SubResource( 277 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 27
mask = 4294967291
my_seed = 3112
use_same_seed = true

[node name="stone_gate_vault" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 1159, -366 )
script = ExtResource( 19 )
min_size = Vector2( 128, 128 )
all_dimensions = true
variable_size = 0
max_size = Vector2( 256, 256 )
size = Vector2( 128, 128 )
probability = 5
distance_requirements = [ Vector3( 0, 10000, 2 ) ]

[node name="preview" type="Sprite2D" parent="good_rects_presets/stone_gate_vault"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="resource_blob_medium_outline2" type="Sprite2D" parent="good_rects_presets/stone_gate_vault/preview"]
modulate = Color( 0.141176, 0.141176, 0.180392, 1 )
material = SubResource( 278 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 2
mask = 4294967295
my_seed = 3112
use_same_seed = true

[node name="resource_blob_medium_outline3" type="Sprite2D" parent="good_rects_presets/stone_gate_vault/preview"]
modulate = Color( 0, 0.333333, 1, 1 )
material = SubResource( 279 )
position = Vector2( 0.1, 0.1 )
scale = Vector2( 0.8, 0.8 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 25
mask = 4294967295
my_seed = 3112
use_same_seed = true

[node name="crafted_rect_test" type="Node2D" parent="good_rects_presets"]
visible = false
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 1570, -365 )
script = ExtResource( 20 )
min_size = Vector2( 128, 128 )
all_dimensions = true
size = Vector2( 32, 32 )
rect_list = [ "TestRect" ]

[node name="preview" type="Sprite2D" parent="good_rects_presets/crafted_rect_test"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="Blob" type="Sprite2D" parent="good_rects_presets/crafted_rect_test/preview"]
scale = Vector2( 0.0078125, 0.0078125 )
centered = false
script = ExtResource( 21 )
material_type = 25
use_rect_as_size = true

[node name="empty" type="Node2D" parent="good_rects_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( 1360, -365 )
script = ExtResource( 8 )
min_size = Vector2( 16, 16 )
size = Vector2( 128, 128 )
probability = 400
empty = true

[node name="preview" type="Sprite2D" parent="good_rects_presets/empty"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="cave_presets" type="Node2D" parent="."]

[node name="reactor_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -499, 430 )
script = ExtResource( 12 )
variable_size = 0
size = Vector2( 200, 200 )
remove_if_lava_rect = null

[node name="preview" type="Sprite2D" parent="cave_presets/reactor_rect"]
self_modulate = Color( 0.392157, 0.929412, 0.470588, 0.501961 )
scale = Vector2( 200, 200 )
texture = ExtResource( 4 )
centered = false

[node name="reactor_rect" type="Sprite2D" parent="cave_presets/reactor_rect/preview"]
material = SubResource( 243 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="spawner_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -280, 430 )
script = ExtResource( 14 )
variable_size = 0
size = Vector2( 200, 200 )
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="cave_presets/spawner_rect"]
self_modulate = Color( 0.929412, 0.392157, 0.447059, 0.501961 )
scale = Vector2( 200, 200 )
texture = ExtResource( 4 )
centered = false

[node name="spawner_rect" type="Sprite2D" parent="cave_presets/spawner_rect/preview"]
material = SubResource( 267 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="boss_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -499, 646 )
script = ExtResource( 22 )
size = Vector2( 32, 32 )
is_boss = true

[node name="preview" type="Sprite2D" parent="cave_presets/boss_rect"]
self_modulate = Color( 0.929412, 0.737255, 0.392157, 0.501961 )
scale = Vector2( 32, 32 )
texture = ExtResource( 4 )
centered = false

[node name="boss_rect" type="Sprite2D" parent="cave_presets/boss_rect/preview"]
material = SubResource( 280 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="nest_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -280, 646 )
script = ExtResource( 8 )
size = Vector2( 200, 200 )
remove_if_lava_rect = true

[node name="preview" type="Sprite2D" parent="cave_presets/nest_rect"]
self_modulate = Color( 0.615686, 0.392157, 0.929412, 0.501961 )
scale = Vector2( 200, 200 )
texture = ExtResource( 4 )
centered = false

[node name="nest_rect" type="Sprite2D" parent="cave_presets/nest_rect/preview"]
material = SubResource( 281 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="mine_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -492, 863 )
script = ExtResource( 15 )
size = Vector2( 200, 200 )

[node name="preview" type="Sprite2D" parent="cave_presets/mine_rect"]
self_modulate = Color( 0.392157, 0.858824, 0.929412, 0.501961 )
scale = Vector2( 200, 200 )
texture = ExtResource( 4 )
centered = false

[node name="mine_rect" type="Sprite2D" parent="cave_presets/mine_rect/preview"]
material = SubResource( 288 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="cave_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -272, 863 )
script = ExtResource( 22 )
variable_size = 0
size = Vector2( 128, 128 )

[node name="preview" type="Sprite2D" parent="cave_presets/cave_rect"]
self_modulate = Color( 0.717647, 0.67451, 0.666667, 0.501961 )
scale = Vector2( 128, 128 )
texture = ExtResource( 4 )
centered = false

[node name="cave_rect" type="Sprite2D" parent="cave_presets/cave_rect/preview"]
material = SubResource( 283 )
texture = ExtResource( 6 )
centered = false
script = ExtResource( 2 )
material_type = 25
my_seed = 3911

[node name="lava_rect" type="Node2D" parent="cave_presets"]
self_modulate = Color( 0.392157, 0.584314, 0.929412, 0.5 )
position = Vector2( -492, 1083 )
script = ExtResource( 17 )
variable_size = 0
size = Vector2( 100, 100 )

[node name="preview" type="Sprite2D" parent="cave_presets/lava_rect"]
self_modulate = Color( 0.807843, 0.368627, 0, 0.741176 )
scale = Vector2( 100, 100 )
texture = ExtResource( 4 )
centered = false

[node name="lava_outline" type="Sprite2D" parent="cave_presets/lava_rect/preview"]
modulate = Color( 1, 0.5, 1, 1 )
material = SubResource( 284 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 27
mask = 4093640703
my_seed = 3112
use_same_seed = true

[node name="lava_source_lava" type="Sprite2D" parent="cave_presets/lava_rect/preview"]
modulate = Color( 1, 0.5, 0.16, 1 )
material = SubResource( 285 )
position = Vector2( 0.5, 0.5 )
scale = Vector2( 0.4, 0.4 )
texture = ExtResource( 6 )
script = ExtResource( 2 )
material_type = 30
mask = 4227858431
blue_channel = 1
my_seed = 3112
use_same_seed = true

[node name="lava" type="Sprite2D" parent="cave_presets/lava_rect/preview"]
modulate = Color( 1, 0.5, 0.16, 1 )
material = SubResource( 286 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 30
mask = 4227858431
blue_channel = 1
my_seed = 3112
use_same_seed = true

[node name="preview" type="Node2D" parent="."]
visible = false
scale = Vector2( 4000, 4000 )
z_index = 554

[node name="map" type="Sprite2D" parent="preview"]
unique_name_in_owner = true
material = ExtResource( 5 )
scale = Vector2( 0.00025, 0.00025 )
texture = SubResource( 289 )
centered = false

[node name="GeneratedMapBase" type="Sprite2D" parent="."]
unique_name_in_owner = true
self_modulate = Color( 0, 0, 0, 0 )
scale = Vector2( 2048, 2048 )
z_index = 346
texture = ExtResource( 4 )
centered = false
script = ExtResource( 3 )
spawner_rect_size = 100
boss_rect_size = 100
nest_rect_size = 100
mine_rect_size = 100
cave_rect_size = 80

[node name="full_dirt" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.262745, 0.211765, 0.137255, 1 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )

[node name="bedrock_new" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.141176, 0.141176, 0.180392, 1 )
material = SubResource( 43 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 2
my_seed = 4269

[node name="bedrock_dirt_patches" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.262745, 0.211765, 0.137255, 1 )
material = SubResource( 68 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
mask = 4
my_seed = -407

[node name="clay_new" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.352941, 0.341177, 0.360784, 1 )
material = SubResource( 196 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 1
mask = 4093640695
my_seed = -1508

[node name="clay_dirt_patches" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.262745, 0.211765, 0.137255, 1 )
material = SubResource( 197 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
mask = 2
my_seed = -6572

[node name="lumen_swirls_new" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 1, 0.5, 1, 1 )
material = SubResource( 36 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 27
mask = 4294967291
my_seed = 3499

[node name="lumen_dirt_patches" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.262745, 0.211765, 0.137255, 1 )
material = SubResource( 37 )
position = Vector2( 0, -9.53674e-10 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
mask = 134217728
my_seed = -6426

[node name="metal_swirls_new" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.384314, 0.180392, 0.0980392, 1 )
material = SubResource( 54 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
material_type = 3
mask = 4160749563
my_seed = 7112

[node name="metal_dirt_patches" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.262745, 0.211765, 0.137255, 1 )
material = SubResource( 55 )
texture = ExtResource( 4 )
centered = false
script = ExtResource( 2 )
mask = 8
my_seed = -749

[node name="caves_gen" type="ProceduralMapCavesGenerator" parent="GeneratedMapBase"]
unique_name_in_owner = true
scale = Vector2( 0.000488281, 0.000488281 )
script = ExtResource( 10 )
keep_scale = true

[node name="bedrock_smooth" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.141176, 0.141176, 0.180392, 1 )
material = SubResource( 131 )
scale = Vector2( 0.000651042, 0.000651042 )
centered = false
script = ExtResource( 2 )
material_type = 2
mask = 4
my_seed = -7181
keep_scale = true
needs_duplicate_texture = true

[node name="clay_smooth" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.352941, 0.341177, 0.360784, 1 )
material = SubResource( 198 )
scale = Vector2( 0.000651042, 0.000651042 )
centered = false
script = ExtResource( 2 )
material_type = 1
mask = 2
my_seed = 7798
keep_scale = true
needs_duplicate_texture = true

[node name="metal_smooth" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0.384314, 0.180392, 0.0980392, 1 )
material = SubResource( 132 )
scale = Vector2( 0.000651042, 0.000651042 )
centered = false
script = ExtResource( 2 )
material_type = 3
mask = 8
my_seed = -5271
keep_scale = true
needs_duplicate_texture = true

[node name="lumen_smooth" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 1, 0.5, 1, 1 )
material = SubResource( 130 )
scale = Vector2( 0.000651042, 0.000651042 )
centered = false
script = ExtResource( 2 )
material_type = 27
mask = 134217728
my_seed = -9739
keep_scale = true
needs_duplicate_texture = true

[node name="caves_smooth" type="Sprite2D" parent="GeneratedMapBase"]
modulate = Color( 0, 0.286275, 1, 1 )
material = SubResource( 134 )
scale = Vector2( 0.000651042, 0.000651042 )
centered = false
script = ExtResource( 2 )
material_type = 25
mask = 33554432
my_seed = 3410
keep_scale = true
needs_duplicate_texture = true

[node name="generated_rects" type="Sprite2D" parent="."]
unique_name_in_owner = true
self_modulate = Color( 0, 0.439216, 0.478431, 0 )
z_index = 595
texture = ExtResource( 4 )
script = ExtResource( 7 )

[node name="swarm_batchs" type="Node2D" parent="."]
unique_name_in_owner = true

[node name="Objects" type="Node2D" parent="."]
unique_name_in_owner = true
