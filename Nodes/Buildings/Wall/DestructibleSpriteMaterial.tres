[gd_resource type="ShaderMaterial" load_steps=4 format=3 uid="uid://cb0cb7o0ylqc"]

[ext_resource type="Texture2D" uid="uid://dbm6faqljvboj" path="res://Resources/Textures/Cracks.png" id="1"]
[ext_resource type="Texture2D" uid="uid://dqmgebadythey" path="res://Resources/Textures/NoiseRGB.png" id="2"]

[sub_resource type="Shader" id="9"]
code = "shader_type canvas_item;
render_mode skip_vertex_transform ;

uniform mat4 global_transform;

uniform bool let_me_see= false;
uniform float masked_material_number= 26.0;
uniform float random_blur =0.5;
uniform float shuffle_tile_border =4.0;
uniform float blur_amount =1.5;
uniform float random_blur_border =4.0;
uniform float random_noise_mul =2.0;


uniform sampler2D crack_tiled;
uniform float crack_tile_mul =5.0;

uniform sampler2D random_noise;
uniform sampler2D map_tex;

varying vec2 global_position;
varying vec2 worldUV;



void vertex()
{
	
global_position=(global_transform * vec4(VERTEX, 1.0, 1.0)).xy;
	//VERTEX = (EXTRA_MATRIX * (WORLD_MATRIX * vec4(VERTEX, 1.0, 1.0))).xy;
// VERTEX=(WORLD_MATRIX*vec4(VERTEX,1.0,1.0)).xy;

global_position = (global_transform * vec4(VERTEX, 0.0, 1.0)).xy;
// UV=(vec4(UV,1.0,1.0)*inverse(WORLD_MATRIX)).xy;
}

float when_eq(float x, float y) {
  return 1.0 - abs(sign(x - y));
}

float when_neq(float x, float y) {
  return abs(sign(x - y));
}




vec3 addCracks(vec2 UV_in_scaled, vec4 real_col, vec4 col)
{
	vec4 crack=texture(crack_tiled, vec2(UV_in_scaled*crack_tile_mul)); 
	vec4 crack_small=texture(crack_tiled, vec2(UV_in_scaled*crack_tile_mul)*3.0); 
	//commented section is to disable cracks on some material	
	float healthy=clamp(1.0-(pow(real_col.r,3.0)/*+is_res1*/),0.0,1.0);
	return col.a*(((1.0-crack.rgb*1.0)*healthy+(3.0-crack_small.rgb*3.0)*clamp(healthy-0.6,0.0,1.0))); //crack damaged terrain	
}


vec4 getMapColor(sampler2D map_texture,vec2 UV_in)
{
	vec2 tex_size=vec2(textureSize(map_texture,0));
	vec2 inv_size=1.0/tex_size;

	//vec4 real_col=texture(map_texture, UV_in);
	vec4 real_col=texelFetch(map_texture,ivec2(UV_in*tex_size),0);
	
	vec2 UV_in_scaled=UV_in*tex_size*0.001;

	vec2 random_blur_border_scaled=random_blur_border*inv_size;
	
	//used for alpha
	//vec4 col=textureLod(map_texture, UV_in+ random_blur_scaled* (texture(random_noise,UV_in_scaled*random_noise_mul).r-0.5),blur_amount);
	vec4 col=textureLod(map_texture, UV_in+ random_blur_border_scaled* (texture(random_noise,UV_in_scaled*random_noise_mul).rg-vec2(0.55)),blur_amount);
	//vec4 col_zero=textureLod(map_texture, UV_in+ random_blur_border_scaled* (texture(random_noise,UV_in_scaled*random_noise_mul).rg-vec2(0.55)),0);
	
	
	vec4 outCOLOR;

	{

		outCOLOR=vec4(1.0);
		outCOLOR.rgb-=addCracks(UV_in_scaled,real_col,col);
	}
	
	
	
	//if(col.a<cutoff)
	{
		//DARK AMBIENT, FROM BORDER OF TERRAIN TO EMPTY
		outCOLOR.rgb-=1.0*(1.0-col.a);
		outCOLOR.rgb*=pow(col.a,3.0);
		outCOLOR.a=pow(min(1.0,col.a),0.6);
	}

	float difference_material_type = abs(col.g-masked_material_number/255.0);
	float max_material_diff = 16.0/255.0;
	if(difference_material_type > 0.001) outCOLOR.rgb = outCOLOR.rgb*pow(1.0-min(difference_material_type/max_material_diff, 1.0),2.0);

	return vec4(outCOLOR.rgb,col.a*float(abs(real_col.g-(masked_material_number/255.0))<=0.001));
}

void fragment()
{		
	COLOR=texture(TEXTURE,UV)*getMapColor(map_tex,global_position/vec2((textureSize(map_tex,0))));
	if(let_me_see)
		COLOR=texture(TEXTURE,UV);
	
}"

[resource]
shader = SubResource("9")
shader_parameter/global_transform = Projection(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
shader_parameter/let_me_see = false
shader_parameter/masked_material_number = 26.0
shader_parameter/random_blur = 0.5
shader_parameter/shuffle_tile_border = 4.0
shader_parameter/blur_amount = 1.5
shader_parameter/random_blur_border = 4.0
shader_parameter/random_noise_mul = 2.0
shader_parameter/crack_tiled = ExtResource("1")
shader_parameter/crack_tile_mul = 3.306
shader_parameter/random_noise = ExtResource("2")
